from typing import ClassVar, Dict, List, Tuple

import numpy
ambient_conditions: InitialisationMethod
bottom: Face
connected: BoundaryCondition
constant: MeshSpacingType
exponential: MeshSpacingType
from_chapman_jouget_solution: InitialisationMethod
from_input_data: InitialisationMethod
left: Face
linear: MeshSpacingType
min_mod: FluxLimiterType
no_slip: BoundaryCondition
none: FluxLimiterType
not_set: BoundaryCondition
parabolic: MeshSpacingType
right: Face
slip: BoundaryCondition
straight_double_tapered: BeamProfile
super_bee: FluxLimiterType
supersonic_inlet: BoundaryCondition
supersonic_outlet: BoundaryCondition
top: Face
van_albada_one: FluxLimiterType
van_albada_two: FluxLimiterType
zero: InitialisationMethod

class AmbientConditions:
    free_flow_x_velocity: float
    free_flow_y_velocity: float
    mach: float
    static_pressure: float
    temperature: float
    def __init__(self) -> None: ...

class BeamProfile:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    straight_double_tapered: ClassVar[BeamProfile] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Boundary:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def boundary_type(self) -> EBoundaryCondition: ...

class BoundaryCondition:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    connected: ClassVar[BoundaryCondition] = ...
    no_slip: ClassVar[BoundaryCondition] = ...
    not_set: ClassVar[BoundaryCondition] = ...
    slip: ClassVar[BoundaryCondition] = ...
    supersonic_inlet: ClassVar[BoundaryCondition] = ...
    supersonic_outlet: ClassVar[BoundaryCondition] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ChapmanJougetInitialConditionParameters:
    beam_power: float
    energy_absorption_coefficient: float
    ideal_gas_constant: float
    specific_heat_ratio: float
    def __init__(self) -> None: ...

class Domain:
    def __init__(self, *args, **kwargs) -> None: ...
    def SetBoundaryType(self, arg0: EFace, arg1: EBoundaryCondition) -> None: ...
    @property
    def density(self) -> FieldQuantity: ...
    @property
    def enthalpy(self) -> FieldQuantity: ...
    @property
    def internal_energy(self) -> FieldQuantity: ...
    @property
    def pressure(self) -> FieldQuantity: ...
    @property
    def temperature(self) -> FieldQuantity: ...
    @property
    def velocity_r(self) -> FieldQuantity: ...
    @property
    def velocity_x(self) -> FieldQuantity: ...

class Face:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    bottom: ClassVar[Face] = ...
    left: ClassVar[Face] = ...
    right: ClassVar[Face] = ...
    top: ClassVar[Face] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FieldQuantity:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def current_time_step(self) -> TwoDimensionalArray: ...
    @property
    def rungeKuttaBuffer(self) -> TwoDimensionalArray: ...

class FluxLimiterType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    min_mod: ClassVar[FluxLimiterType] = ...
    none: ClassVar[FluxLimiterType] = ...
    super_bee: ClassVar[FluxLimiterType] = ...
    van_albada_one: ClassVar[FluxLimiterType] = ...
    van_albada_two: ClassVar[FluxLimiterType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class InitialisationMethod:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    ambient_conditions: ClassVar[InitialisationMethod] = ...
    from_chapman_jouget_solution: ClassVar[InitialisationMethod] = ...
    from_input_data: ClassVar[InitialisationMethod] = ...
    zero: ClassVar[InitialisationMethod] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MaterialProperties:
    density: float
    youngs_modulus: float
    def __init__(self) -> None: ...

class MeshSpacing:
    amount_of_elements: int
    left: float
    right: float
    type: EMeshSpacingType
    def __init__(self) -> None: ...

class MeshSpacingType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    constant: ClassVar[MeshSpacingType] = ...
    exponential: ClassVar[MeshSpacingType] = ...
    linear: ClassVar[MeshSpacingType] = ...
    parabolic: ClassVar[MeshSpacingType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Position:
    def __init__(self, arg0: float, arg1: float) -> None: ...
    @property
    def up_direction(self) -> EFace: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...

class ReedValve:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def hinge_position_in_domain(self) -> Position: ...
    @property
    def hole_end_position_in_domain(self) -> Position: ...

class ReedValveEmpiricalParameters:
    aerodynamic_damping_c1: float
    aerodynamic_damping_c2: float
    aerodynamic_damping_c3: float
    hole_factor: float
    natural_frequency: float
    rayleigh_damping_alpha: float
    rayleigh_damping_beta: float
    def __init__(self) -> None: ...

class ReedValveGeometry:
    free_length: float
    root_thickness: float
    root_width: float
    tip_thickness: float
    tip_width: float
    def __init__(self) -> None: ...

class RuntimeParameters:
    time_steps_between_data_export: int
    def __init__(self) -> None: ...

class SimCase:
    dt: float
    simulation_duration: float
    def __init__(self) -> None: ...
    def AddDomain(self, arg0: int, arg1: str, arg2: Position, arg3: Tuple[float,float], arg4: Tuple[MeshSpacing,MeshSpacing], arg5: EInitialisationMethod) -> Domain: ...
    def AddRecord(self, arg0: TwoDimensionalArray, arg1: str) -> None: ...
    def ConnectBoundariesById(self, arg0: int, arg1: EFace, arg2: int, arg3: EFace) -> None: ...
    def ConnectBoundariesByName(self, arg0: str, arg1: EFace, arg2: str, arg3: EFace) -> None: ...
    def GetDomainByID(self, arg0: int) -> Domain: ...
    def GetDomainByName(self, arg0: str) -> Domain: ...
    @property
    def domains(self) -> Dict[int,Domain]: ...
    @property
    def two_dimensional_array_records(self) -> Dict[str,TwoDimensionalArrayRecord]: ...

class SolverSettings:
    amount_of_ghost_cells: int
    ausm_switch_bias: float
    entropy_fix: float
    flux_limiter_type: int
    muscl_bias: float
    runge_kutta_order: int
    def __init__(self) -> None: ...

class TwoDimensionalArray:
    def __init__(self, *args, **kwargs) -> None: ...
    def GetAt(self, arg0: int, arg1: int) -> float: ...
    @property
    def size_x(self) -> int: ...
    @property
    def size_y(self) -> int: ...

class TwoDimensionalArrayRecord:
    def __init__(self, *args, **kwargs) -> None: ...
    def AsNumpyArray(self, arg0: int) -> numpy.ndarray[numpy.float64]: ...
    @property
    def records(self) -> List[TwoDimensionalArray]: ...

def DoSimulation(arg0: SimCase) -> None: ...
def FillTwoDimensionalArrayFromNumpy(arg0: TwoDimensionalArray, arg1: numpy.ndarray[numpy.float64]) -> None: ...
def TwoDimensionalArrayToNumpyArray(arg0: TwoDimensionalArray) -> numpy.ndarray[numpy.float64]: ...
